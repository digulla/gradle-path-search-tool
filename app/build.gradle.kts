import PathSearcher
import PathSearcherBuilder

/*
 * This file was generated by the Gradle 'init' task.
 *
 * This project uses @Incubating APIs which are subject to change.
 */

plugins {
    id("buildlogic.kotlin-application-conventions")
}

dependencies {
    implementation("org.apache.commons:commons-text")
    //implementation(project(":utilities"))
}

application {
    // Define the main class for the application.
    mainClass = "org.example.app.AppKt"
}

val pathSearcher = PathSearcher()
val echoCommand = pathSearcher.locate("echo")
val echoTask = task<Exec>("echoTask") {
    println("echoCommand=$echoCommand")
	commandLine(echoCommand, "echoTask:", "$echoCommand", "works")
}

val echoTask2 = task<ExecWithPathTask>("echoTask2") {
    command(echoCommand)
    arguments("echoTask2:", "$echoCommand", "works")
}

val cachableTask = task<ExecWithPathTask>("cachableTask") {
    command("echo", pathSearcher)
    arguments("cachableTask, you should see this only once", System.getenv("CACHE_TEST") ?: "CACHE_TEST is not set")
    enableCaching()
}

println("--- missingCommand, reported at configuration time --------------------------------------------")
try {
    task<ExecWithPathTask>("missingCommand") {
        command("no-such-command", pathSearcher)
    }
} catch(e: Exception) {
    println(e.message)
}
println("--- missingCommand, reported at configuration time --------------------------------------------")

// Run this manually from the commandline to see the error you get when a command fails
// > ./gradlew :app:failingCommand
// > ./gradlew :app:failingCommand --stacktrace
task<ExecWithPathTask>("failingCommand") {
    if (PathSearcher.isWindows()) {
        // TODO Untested
        val searchProjectRoot = PathSearcherBuilder().add(project.rootDir.toPath()).build()
        command("always-fail", searchProjectRoot)
    } else {
        command("sh", pathSearcher)
        arguments("-c", "exit 1")
    }
}

/*
Things I hate about Gradle: There is a lot of documentation which almost answers my questions.
Googling doesn't work since they changed so many things between versions and answers never
say "this works for Gradle Vx.y", so it's a guessing game.

Things that I tried:

Attempt 1 ---------------------------------------
compileKotlin.dependsOn(echoTask)

  Line 39: compileKotlin.dependsOn(echoTask)
           ^ Unresolved reference. None of the following candidates is applicable because of receiver type mismatch: 
               public val TaskContainer.compileKotlin: TaskProvider<KotlinCompile> defined in org.gradle.kotlin.dsl

What is a "receiver type"? And what is the type in this case?

Attempt 2 ---------------------------------------
val compileKotlin: KotlinCompile by tasks
compileKotlin.dependsOn(echoTask)

  Line 47: val compileKotlin: KotlinCompile by tasks
                              ^ Unresolved reference: KotlinCompile

  Line 47: val compileKotlin: KotlinCompile by tasks
                                               ^ Property delegate must have a 'getValue(Build_gradle, KProperty<*>)' method. None of the following functions is suitable: 
                                                   public inline operator fun <T : Any, reified U : Task!> NamedDomainObjectProvider<out Task!>.getValue(thisRef: Any?, property: KProperty<*>): Task defined in org.gradle.kotlin.dsl

I can write code in Kotlin but KotlinCompile isn't on the classpath?
Importing doesn't work, either. What's the fully qualified classname??
I got this from Stackoverflow. Is this answer outdated? How could I tell?

Attempt 3 ---------------------------------------
See below. It took me half an hour to write two lines of code.
As a build tools go, Gradle doesn't make me efficient.
*/

tasks.named("compileKotlin", org.jetbrains.kotlin.gradle.tasks.KotlinJvmCompile::class.java) {
    dependsOn(echoTask)
    dependsOn(echoTask2)
    dependsOn(cachableTask)
}
